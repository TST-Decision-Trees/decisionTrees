<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="A generative art game where you climb a fractal tree by answering questions."
    />
    <title>Understanding Decision Trees</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
      :root {
        --bg-color: #030712;
        --glow-color: #00ffff;
        --text-color: #f0f8ff;
        --dim-color: #475569;
        --accent-color: #f3540a;
        --visited-color: #22c55e;
        --wrong-color: #f43f5e;
        --soil-color: #6b462a;
        --grass-color: #4ade80;
        --sidebar-bg: #0f172a;
        --font-main: "Segoe UI", "Roboto", "Helvetica Neue", system-ui,
          sans-serif;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: var(--font-main);
      }

      body {
        display: flex;
        flex-direction: column;
      }

      .top-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem 1.5rem;
        background-color: #091111;
        border-bottom: 1px solid var(--dim-color);
      }

      .top-header .header-logo {
        height: 7.5vh; /* 10% of the viewport height */
      }

      .header-title {
        text-align: center;
      }

      .top-header h1 {
        font-size: 2.75rem;
        color: var(--accent-color);
        margin: 0;
      }

      .header-title h4 {
        font-size: 1rem;
        font-weight: normal;
        margin: 0.25rem 0 0 0;
        color: var(--text-color);
      }

      #main-container {
        display: flex;
        flex: 1; /* This makes the container grow to fill remaining space */
        min-height: 0; /* Prevents flexbox overflow issues */
      }

      #simulation-wrapper {
        flex: 1;
        position: relative;
        min-height: 0;
        min-width: 0; /* Prevents flexbox from collapsing canvas */
      }

      #sidebar,
      #right-sidebar {
        width: 320px;
        flex-shrink: 0;
        background-color: var(--sidebar-bg);
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
      }

      #sidebar {
        border-right: 1px solid var(--dim-color);
      }

      #right-sidebar {
        border-left: 1px solid var(--dim-color);
        align-items: center;
        gap: 1.5rem;
      }

      .game-stats {
        width: 100%;
        display: flex;
        justify-content: space-around;
        background: rgba(3, 7, 18, 0.7);
        padding: 0.75rem 1.25rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-sizing: border-box;
      }

      .carousel-container {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        min-height: 0; /* Allow container to shrink and content to scroll */
      }

      .carousel-slides {
        border-radius: 8px;
      }

      .carousel-slide {
        display: none;
        padding: 1rem;
        background: rgba(3, 7, 18, 0.5);
        box-sizing: border-box;
      }

      .carousel-slide p {
        font-size: 0.95rem;
        line-height: 1.5;
      }

      .carousel-slide.active {
        display: block;
      }

      .carousel-slide h3 {
        color: var(--accent-color);
        margin-top: 0;
      }

      .carousel-controls {
        display: flex;
        justify-content: space-between;
        margin-top: 1rem;
      }

      .carousel-controls button {
        background: var(--accent-color);
        color: var(--bg-color);
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
      }

      .complexity-slider {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--text-color);
      }

      .complexity-slider input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 120px;
        height: 8px;
        background: var(--dim-color);
        border-radius: 5px;
        outline: none;
        cursor: pointer;
      }

      .complexity-slider input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: var(--accent-color);
        border-radius: 50%;
        cursor: pointer;
      }

      .complexity-slider input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: var(--accent-color);
        border-radius: 50%;
        cursor: pointer;
      }

      /* The p5.js canvas will be placed here */
      #canvas-container {
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .footer {
        pointer-events: all;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 100%;
        gap: 1rem;
      }

      /* Non-intrusive Question Panel */
      .question-panel {
        display: none; /* Hidden by default */
        width: 100%;
        text-align: center;
        pointer-events: all;
      }

      .question-panel.visible {
        display: block; /* Shown when active */
      }

      .question {
        font-size: 1.25rem;
        color: var(--accent-color);
        margin-bottom: 1rem;
        line-height: 1.4;
      }

      #reset-view-btn {
        padding: 0.6rem 1.2rem;
        font-size: 0.9rem;
        background: var(--dim-color);
        border-color: var(--dim-color);
      }

      .answers {
        display: flex;
        gap: 1rem;
        justify-content: center;
      }

      .answers button {
        flex-grow: 1;
        padding: 1rem;
        font-size: 1rem;
        background-color: var(--accent-color);
        color: var(--bg-color);
        font-weight: bold;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .answers button:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 20px rgba(56, 189, 248, 0.3);
      }

      .game-button {
        padding: 1rem 2rem;
        border: 1px solid var(--accent-color);
        background: var(--accent-color);
        color: var(--bg-color);
        border-radius: 8px;
        cursor: pointer;
        font-size: 1.2rem;
        font-weight: bold;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .game-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(56, 189, 248, 0.4);
      }

      #end-summary {
        background: rgba(3, 7, 18, 0.8);
        backdrop-filter: blur(10px);
        padding: 1.5rem;
        border-radius: 12px;
        border: 1px solid var(--accent-color);
        text-align: center;
      }
    </style>
  </head>

  <body>
    <header class="top-header">
      <img
        src="http://threespirestrust.org/wp-content/uploads/2022/01/Three-Spires-Trust-Logo.png"
        alt="Header Logo"
        class="header-logo"
      />
      <div class="header-title">
        <h1>Treevia!</h1>
        <h4>A trivia game that teaches you how decision trees work</h4>
      </div>
      <img
        src="https://tst-decision-trees.github.io/decisionTrees/Images/HAU_full_wordmarque_white.png"
        alt="Harper Adams Logo"
        class="header-logo"
      />
    </header>
    <div id="main-container">
      <aside id="sidebar">
        <div class="carousel-container">
          <h2>How Decision Trees Work</h2>
          <div class="carousel-slides" id="carousel-slides">
            <!-- Slides will be injected by JS -->
          </div>
          <div class="carousel-controls">
            <button id="carousel-prev">Previous</button>
            <button id="carousel-next">Next</button>
          </div>
        </div>
      </aside>
      <div id="simulation-wrapper">
        <div id="canvas-container"></div>
      </div>
      <aside id="right-sidebar">
        <div class="game-stats">
          <span>Score: <span id="score">0</span></span>
          <span>Penalty: <span id="penalty">0</span></span>
        </div>
        <div class="footer" id="footer-controls">
          <div
            id="start-controls"
            style="
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 1rem;
            "
          >
            <button id="start-btn" class="game-button">Start Quiz</button>
            <div class="complexity-slider">
              <label for="complexity">Complexity:</label>
              <input
                type="range"
                id="complexity"
                name="complexity"
                min="1"
                max="5"
                value="3"
              />
              <span id="complexity-value">3</span>
            </div>
          </div>
          <div id="end-summary-wrapper" style="display: none"></div>
          <button id="restart-btn" class="game-button" style="display: none">
            Play Again
          </button>
        </div>
        <div class="question-panel" id="question-panel">
          <h2 class="question" id="question-text"></h2>
          <div class="answers" id="answers-container"></div>
        </div>
        <button id="reset-view-btn" class="game-button">Reset View</button>
      </aside>
    </div>

    <script>
      // --- CAROUSEL LOGIC ---
      const carousel = {
        slides: [
          {
            title: "Welcome to Treevia!",
            text: "This game teaches you how decision trees work. Your goal is to learn, the quiz is just a fun way to do it! <br><br><strong>How to Play:</strong><br>1. Use the controls on the right panel to start the quiz.<br>2. As you answer, you'll be climbing the tree in the center.<br>3. After each answer, a new fact will appear here, read it carefully to learn something new about decision trees. Focus on learning!.<br><br><strong>Explore:</strong> Adjusting the complexity slider will change the size of the tree and the number of questions you're asked. You can zoom (mouse wheel) and pan (click & drag) the tree to see your path clearly. The 'Previous'/'Next' buttons are just for re-reading. Have fun!",
          },
          {
            title: "Nodes & Decisions",
            text: 'A decision tree starts at the base of the tree going up. Then, each point where the tree splits into two or more branches is a called a "node". This is like a crossroad where artificial intelligence (AI) has to decide which path to take. In this case, you are the AI. Your intelligent answer to the quiz question determines which path to take up the tree.',
          },
          {
            title: "Branches & Outcomes",
            text: 'The lines connecting the nodes are "branches". Each branch represents the outcome of a decision. Choosing a correct answer sends you up an optimal branch, while a wrong answer leads down a different path.',
          },
          {
            title: "The Full Path",
            text: "Where you finally end up depends on the entire chain of decisions you made. The goal of a machine learning model is to tune the tiny algorithm at each node to create the best possible chain of decisions.",
          },
          {
            title: "Leaf Nodes: The End",
            text: 'The tips of the tree that don\'t branch any further are "leaf nodes". Reaching a leaf means the decision process is complete. In this game, it marks the end of your ascent, and your score is finalized.',
          },
          {
            title: "Winning vs. Losing",
            text: 'In a real model, some leaf nodes are "success" and others are "failure". Here, the highest leaves are good outcomes, reached by correct answers. Lower leaves are suboptimal, reached when you make a mistake.',
          },
          {
            title: "Data Determines the Path",
            text: 'Think of this tree like a dichotomous key. The same tree structure can give many different final outcomes because the path taken is determined by the "data" you provide—your answers. In the real world, a model fed with different data will follow different decision paths to reach different conclusions.',
          },
        ],
        currentIndex: 0,

        init() {
          this.renderSlides();
          document
            .getElementById("carousel-next")
            .addEventListener("click", () => this.next());
          document
            .getElementById("carousel-prev")
            .addEventListener("click", () => this.prev());
          this.showSlide(0);
        },

        renderSlides() {
          const container = document.getElementById("carousel-slides");
          container.innerHTML = this.slides
            .map(
              (slide, index) => `
            <div class="carousel-slide" data-index="${index}">
                <h3>${slide.title}</h3>
                <p>${slide.text}</p>
            </div>
        `
            )
            .join("");
        },

        showSlide(index) {
          this.currentIndex = (index + this.slides.length) % this.slides.length;
          const slides = document.querySelectorAll(".carousel-slide");
          slides.forEach((slide) => {
            slide.classList.remove("active");
          });
          document
            .querySelector(`.carousel-slide[data-index="${this.currentIndex}"]`)
            .classList.add("active");
        },

        next() {
          this.showSlide(this.currentIndex + 1);
        },

        prev() {
          this.showSlide(this.currentIndex - 1);
        },
      };

      // --- GAME STATE & LOGIC ---
      const game = {
        score: 0,
        penalty: 0,
        highScore: 0,
        moves: 0,
        tree: [],
        questions: {},
        currentNode: null,
        path: [],
        state: "PRE_START", // PRE_START, PLAYING, FINISHED
        questionPool: [
          // Questions with 4 answers
          {
            q: "Which of these is NOT a primary color?",
            a: ["Green", "Red", "Blue", "Yellow"],
          },
          {
            q: "Which planet is known as the Red Planet?",
            a: ["Mars", "Jupiter", "Venus", "Saturn"],
          },
          {
            q: 'Who wrote "To Kill a Mockingbird"?',
            a: [
              "Harper Lee",
              "Mark Twain",
              "F. Scott Fitzgerald",
              "Ernest Hemingway",
            ],
          },
          {
            q: "What is the largest mammal in the world?",
            a: ["Blue Whale", "Elephant", "Giraffe", "Great White Shark"],
          },
          {
            q: "Which country is known as the Land of the Rising Sun?",
            a: ["Japan", "China", "Thailand", "South Korea"],
          },

          // Questions with 3 answers
          {
            q: "What is the main ingredient in guacamole?",
            a: ["Avocado", "Tomato", "Onion"],
          },
          { q: "How many continents are there?", a: ["7", "5", "6"] },
          {
            q: "What is the hardest natural substance on Earth?",
            a: ["Diamond", "Gold", "Iron"],
          },
          {
            q: "Which is the longest river in the world?",
            a: ["The Nile", "The Amazon", "The Yangtze"],
          },
          {
            q: 'What type of animal is a "doe"?',
            a: ["A female deer", "A male deer", "A young sheep"],
          },

          // Questions with 2 answers
          { q: "Is the sun a star or a planet?", a: ["Star", "Planet"] },
          {
            q: "Does sound travel faster in water or in air?",
            a: ["Water", "Air"],
          },
          { q: "What is the chemical symbol for gold?", a: ["Au", "Ag"] },
          { q: "Did the Titanic sink in 1912 or 1915?", a: ["1912", "1915"] },
          {
            q: "Is a tomato a fruit or a vegetable?",
            a: ["Fruit", "Vegetable"],
          },
          { q: "What is the capital of France?", a: ["Paris", "London"] },
          { q: "What is 5 × 6?", a: ["30", "56"] },
          { q: "Which gas do plants absorb?", a: ["Carbon Dioxide", "Oxygen"] },
          { q: "Who wrote Romeo and Juliet?", a: ["Shakespeare", "Dickens"] },
          { q: "Water's boiling point (°C)?", a: ["100", "0"] },
          { q: "Which is Earth's largest ocean?", a: ["Pacific", "Atlantic"] },
          { q: "How many sides in a hexagon?", a: ["6", "8"] },
          { q: 'Which element is "O"?', a: ["Oxygen", "Osmium"] },
          { q: "When did WWII end?", a: ["1945", "1944"] },
          { q: "Square root of 64?", a: ["8", "6"] },
          { q: "Home of the kangaroo?", a: ["Australia", "New Zealand"] },
          { q: "Who painted the Mona Lisa?", a: ["Da Vinci", "Michelangelo"] },
          { q: "Largest human body organ?", a: ["Skin", "Liver"] },
          { q: "Capital of Japan?", a: ["Tokyo", "Kyoto"] },
          { q: "Planet closest to the Sun?", a: ["Mercury", "Venus"] },
        ],
        complexity: 3,

        init() {
          this.highScore = localStorage.getItem("neuralAscentHighScore") || 0;
          document
            .getElementById("start-btn")
            .addEventListener("click", () => this.start());
          document
            .getElementById("restart-btn")
            .addEventListener("click", () => this.restart());

          const complexitySlider = document.getElementById("complexity");
          const complexityValueSpan =
            document.getElementById("complexity-value");
          this.complexity = parseInt(complexitySlider.value, 10);

          complexitySlider.addEventListener("input", (e) => {
            this.complexity = parseInt(e.target.value, 10);
            complexityValueSpan.textContent = this.complexity;
            if (window.p5Instance) {
              window.p5Instance.restart();
            }
          });

          this.updateUI();
        },

        setTree(treeData) {
          this.tree = treeData.tree;
          this.optimalPath = treeData.optimalPath;
          this.assignQuestions();
        },

        start() {
          this.state = "PLAYING";
          this.score = 0;
          this.penalty = 0;
          this.moves = 0;
          this.currentNode = this.tree.find((n) => n.id === "0");
          this.path = [this.currentNode];

          this.updateUI();

          document.getElementById("start-controls").style.display = "none";

          this.showQuestion();
        },

        restart() {
          this.state = "PRE_START";
          window.p5Instance.restart();
        },

        assignQuestions() {
          this.questions = {};
          let questionBank = [...this.questionPool].sort(
            () => 0.5 - Math.random()
          );

          const nodesToAssign = this.tree.filter(
            (node) => node.children.length > 0
          );

          nodesToAssign.forEach((node) => {
            const childCount = node.children.length;
            if (childCount === 0) return;

            // For single-child nodes, we still want a question with at least 2 choices.
            const requiredAnswers = Math.max(childCount, 2);
            let questionIndex = questionBank.findIndex(
              (q) => q.a.length >= requiredAnswers
            );

            // If no suitable question is found, reset and reshuffle the bank
            if (questionIndex === -1) {
              questionBank = [...this.questionPool].sort(
                () => 0.5 - Math.random()
              );
              questionIndex = questionBank.findIndex(
                (q) => q.a.length >= requiredAnswers
              );
              if (questionIndex === -1) {
                console.error(
                  `CRITICAL: No question in the entire pool for a node requiring ${requiredAnswers} answers.`
                );
                return;
              }
            }

            const questionData = questionBank.splice(questionIndex, 1)[0];
            const answers = questionData.a;
            const correctAnswerText = answers[0];
            const incorrectAnswerTexts = [...answers.slice(1)].sort(
              () => 0.5 - Math.random()
            );

            let answerMappings = [];

            if (childCount === 1) {
              const correctChild = node.children[0];
              answerMappings.push({
                text: correctAnswerText,
                isCorrect: true,
                nextNode: correctChild,
              });
              // Add a distractor answer that keeps the user at the current node
              answerMappings.push({
                text: incorrectAnswerTexts[0],
                isCorrect: false,
                nextNode: node,
              });
            } else {
              const correctChild =
                node.children.find((child) =>
                  this.optimalPath.includes(child.id)
                ) || node.children[0];
              const otherChildren = node.children.filter(
                (c) => c.id !== correctChild.id
              );

              answerMappings.push({
                text: correctAnswerText,
                isCorrect: true,
                nextNode: correctChild,
              });

              for (let i = 0; i < otherChildren.length; i++) {
                if (i < incorrectAnswerTexts.length) {
                  answerMappings.push({
                    text: incorrectAnswerTexts[i],
                    isCorrect: false,
                    nextNode: otherChildren[i],
                  });
                }
              }
            }

            this.questions[node.id] = {
              q: questionData.q,
              answers: answerMappings.sort(() => 0.5 - Math.random()),
            };
          });
        },

        showQuestion() {
          const panel = document.getElementById("question-panel");
          if (
            !this.questions[this.currentNode.id] ||
            this.state !== "PLAYING"
          ) {
            panel.classList.remove("visible");
            return;
          }

          const questionText = document.getElementById("question-text");
          const answersContainer = document.getElementById("answers-container");

          const questionData = this.questions[this.currentNode.id];
          questionText.textContent = questionData.q;
          answersContainer.innerHTML = "";

          questionData.answers.forEach((answer) => {
            const button = document.createElement("button");
            button.textContent = answer.text;
            button.onclick = () => this.handleAnswer(answer);
            answersContainer.appendChild(button);
          });

          panel.classList.add("visible");
        },

        handleAnswer(answer) {
          this.moves++;
          if (answer.isCorrect) {
            this.score += 10;
          } else {
            this.score -= 5;
            this.penalty += 5;
          }

          carousel.next(); // Advance carousel on answer

          const nextNode = answer.nextNode;

          // Only add to the path if we are moving to a new node.
          if (this.currentNode.id !== nextNode.id) {
            this.path.push(nextNode);
          }

          this.currentNode = nextNode;

          if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem("neuralAscentHighScore", this.highScore);
          }

          this.updateUI();

          if (
            this.currentNode.children.length > 0 &&
            this.questions[this.currentNode.id]
          ) {
            this.showQuestion();
          } else {
            this.endGame();
          }
        },

        endGame() {
          this.state = "FINISHED";
          document.getElementById("question-panel").classList.remove("visible");

          const summaryHTML = `
            <div id="end-summary">
                <h2>Path Complete</h2>
                <p>Final Score: ${this.score} | Moves: ${this.moves} | Penalties: -${this.penalty}</p>
                <p>Refresh your browser to have another go!</p>
            </div>
        `;
          const summaryWrapper = document.getElementById("end-summary-wrapper");
          summaryWrapper.innerHTML = summaryHTML;
          summaryWrapper.style.display = "block";

          document.getElementById("start-btn").style.display = "none";
        },

        updateUI() {
          document.getElementById("score").textContent = this.score;
          document.getElementById("penalty").textContent = this.penalty;
        },
      };

      // --- P5.JS SKETCH FOR VISUALS ---
      const sketch = (p) => {
        let treeData = {};
        let grassTufts = [];
        const SOIL_Y_OFFSET = 80;
        let soilLevel;

        // Transformation variables
        let viewScale = 1.0;
        let viewX = 0,
          viewY = 0;
        let isPanning = false;

        function generateTreeData(complexity = 3) {
          const tree = [];
          let nodeIdCounter = 0;

          // --- Map complexity to tree parameters ---
          const optimalPathLength = 6 + complexity * 2; // e.g., 8 to 16
          const maxDepth = 10 + complexity * 2; // e.g., 12 to 20
          const mainLength = p.height / (6 + complexity); // Shorter segments for more complex trees

          const root = {
            id: "0",
            pos: p.createVector(p.width / 2, soilLevel),
            children: [],
            depth: 0,
            parent: null,
          };
          tree.push(root);

          const optimalPath = [root];
          let currentOptimal = root;
          for (let i = 1; i < optimalPathLength; i++) {
            const angle = -p.PI / 2 + p.random(-p.PI / 16, p.PI / 16);
            const length =
              p.map(i, 1, optimalPathLength - 1, mainLength, 15) *
              p.random(0.9, 1.1);
            const endPoint = p.createVector(
              currentOptimal.pos.x + length * p.cos(angle),
              currentOptimal.pos.y + length * p.sin(angle)
            );
            const node = {
              id: (++nodeIdCounter).toString(),
              pos: endPoint,
              parent: currentOptimal,
              children: [],
              depth: i,
              optimal: true,
            };
            currentOptimal.children.push(node);
            tree.push(node);
            optimalPath.push(node);
            currentOptimal = node;
          }

          function branch(parent, length, angle, depth, optimalBranch = false) {
            if (depth > maxDepth || length < 8) return;

            const branches = optimalBranch
              ? p.random([1, 2])
              : complexity > 2
              ? p.random([2, 3])
              : p.random([1, 2]);
            for (let i = 0; i < branches; i++) {
              const angleVariation = p.PI / p.map(depth, 1, 10, 4, 8);
              const newAngle =
                angle +
                p.random(-angleVariation, angleVariation) * (i > 0 ? -1 : 1);
              const newLength = length * p.random(0.7, 0.85);

              const endPoint = p.createVector(
                parent.pos.x + newLength * p.cos(newAngle),
                parent.pos.y + newLength * p.sin(newAngle)
              );
              const node = {
                id: (++nodeIdCounter).toString(),
                pos: endPoint,
                parent: parent,
                children: [],
                depth: depth,
                optimal: false,
              };
              parent.children.push(node);
              tree.push(node);
              branch(node, newLength, newAngle, depth + 1);
            }
          }

          tree.forEach((node) => {
            if (node.depth > 0) {
              const initialAngle = node.parent
                ? p.atan2(
                    node.pos.y - node.parent.pos.y,
                    node.pos.x - node.parent.pos.x
                  )
                : -p.PI / 2;
              branch(
                node,
                (p.height / 8) * p.pow(0.8, node.depth),
                initialAngle,
                node.depth + 1,
                node.optimal
              );
            }
          });

          return { tree, optimalPath: optimalPath.map((n) => n.id) };
        }

        p.setup = () => {
          const canvasContainer = document.getElementById("canvas-container");
          p.createCanvas(
            canvasContainer.offsetWidth,
            canvasContainer.offsetHeight
          ).parent(canvasContainer);
          p.restart();
        };

        p.draw = () => {
          p.clear();

          // --- All drawing is now inside the transformation block ---
          p.push();
          p.translate(viewX, viewY);
          p.scale(viewScale);

          // --- Draw background elements first ---
          p.strokeWeight(4 / viewScale);
          p.stroke(
            getComputedStyle(document.documentElement).getPropertyValue(
              "--soil-color"
            )
          );
          p.line(0, soilLevel, p.width, soilLevel);
          grassTufts.forEach((tuft) => {
            p.push();
            p.stroke(
              getComputedStyle(document.documentElement).getPropertyValue(
                "--grass-color"
              )
            );
            p.strokeWeight(tuft.weight / viewScale);
            tuft.blades.forEach((blade) => {
              p.line(tuft.x, soilLevel, tuft.x + blade.x, soilLevel + blade.y);
            });
            p.pop();
          });

          if (!treeData.tree) {
            p.pop();
            return;
          }

          treeData.tree.forEach((node) => {
            if (node.parent) {
              const sw = p.map(node.depth, 1, 12, 10, 1) / viewScale;
              p.strokeWeight(sw);
              p.stroke(
                getComputedStyle(document.documentElement).getPropertyValue(
                  "--dim-color"
                )
              );
              p.line(
                node.parent.pos.x,
                node.parent.pos.y,
                node.pos.x,
                node.pos.y
              );
            }
          });

          if (game.path.length > 1) {
            for (let i = 0; i < game.path.length - 1; i++) {
              const node = game.path[i + 1];
              const sw = p.map(node.depth, 1, 12, 12, 3) / viewScale;
              p.strokeWeight(sw);

              const pathColor = game.path[i + 1].optimal
                ? "--visited-color"
                : "--wrong-color";
              p.stroke(
                getComputedStyle(document.documentElement).getPropertyValue(
                  pathColor
                ) + "80"
              );
              p.line(
                node.parent.pos.x,
                node.parent.pos.y,
                node.pos.x,
                node.pos.y
              );
              p.strokeWeight(sw * 0.6);
              p.stroke(
                getComputedStyle(document.documentElement).getPropertyValue(
                  pathColor
                )
              );
              p.line(
                node.parent.pos.x,
                node.parent.pos.y,
                node.pos.x,
                node.pos.y
              );
            }
          }

          treeData.tree.forEach((node) => {
            const isCurrent = node === game.currentNode;
            const size =
              (isCurrent ? 24 : game.path.includes(node) ? 16 : 10) / viewScale;

            p.noStroke();
            if (isCurrent) {
              p.fill(
                getComputedStyle(document.documentElement).getPropertyValue(
                  "--glow-color"
                ) + "99"
              );
              p.ellipse(node.pos.x, node.pos.y, size * 1.5, size * 1.5);
              p.fill(
                getComputedStyle(document.documentElement).getPropertyValue(
                  "--glow-color"
                )
              );
            } else if (game.path.includes(node)) {
              const nodeColor = node.optimal
                ? "--visited-color"
                : "--wrong-color";
              p.fill(
                getComputedStyle(document.documentElement).getPropertyValue(
                  nodeColor
                )
              );
            } else {
              p.fill(
                getComputedStyle(document.documentElement).getPropertyValue(
                  "--dim-color"
                )
              );
            }
            p.ellipse(node.pos.x, node.pos.y, size, size);
          });

          p.pop();
        };

        p.mouseWheel = (event) => {
          if (
            p.mouseX < 0 ||
            p.mouseX > p.width ||
            p.mouseY < 0 ||
            p.mouseY > p.height
          ) {
            return;
          }
          const zoomFactor = 0.01;
          const oldScale = viewScale;
          viewScale -= event.delta * zoomFactor;
          viewScale = p.constrain(viewScale, 0.2, 50); // Min/max zoom

          // Zoom towards the mouse cursor
          viewX = p.mouseX - (p.mouseX - viewX) * (viewScale / oldScale);
          viewY = p.mouseY - (p.mouseY - viewY) * (viewScale / oldScale);

          return false; // Prevent default page scrolling
        };

        p.mousePressed = () => {
          if (
            p.mouseX > 0 &&
            p.mouseX < p.width &&
            p.mouseY > 0 &&
            p.mouseY < p.height
          ) {
            isPanning = true;
          }
        };

        p.mouseDragged = () => {
          if (isPanning) {
            viewX += p.mouseX - p.pmouseX;
            viewY += p.mouseY - p.pmouseY;
          }
        };

        p.mouseReleased = () => {
          isPanning = false;
        };

        p.windowResized = () => {
          const canvasContainer = document.getElementById("canvas-container");
          p.resizeCanvas(
            canvasContainer.offsetWidth,
            canvasContainer.offsetHeight
          );
          p.restart();
        };

        p.resetView = () => {
          viewScale = 1;
          viewX = 0;
          viewY = 0;
        };

        p.restart = () => {
          const summaryWrapper = document.getElementById("end-summary-wrapper");
          if (summaryWrapper) {
            summaryWrapper.style.display = "none";
            summaryWrapper.innerHTML = "";
          }

          document.getElementById("start-controls").style.display = "flex";
          document.getElementById("restart-btn").style.display = "none";

          p.resetView(); // Reset zoom/pan on restart

          soilLevel = p.height - SOIL_Y_OFFSET;

          // Generate grass
          grassTufts = [];
          for (let i = 0; i < p.width; i += p.random(10, 40)) {
            const tuft = {
              x: i,
              weight: p.random(1, 2.5),
              blades: [],
            };
            const bladeCount = p.random(3, 7);
            for (let j = 0; j < bladeCount; j++) {
              const angle = -p.PI / 2 + p.random(-p.PI / 8, p.PI / 8);
              const length = p.random(5, 20);
              tuft.blades.push({
                x: length * p.cos(angle),
                y: length * p.sin(angle),
              });
            }
            grassTufts.push(tuft);
          }

          treeData = generateTreeData(game.complexity);
          game.setTree(treeData);
          game.state = "PRE_START";
          game.score = 0;
          game.penalty = 0;
          game.updateUI();
        };
      };

      // --- INITIALIZATION ---
      // Moved the entire script to the end of the body to ensure all DOM elements are loaded.
      document.addEventListener("DOMContentLoaded", () => {
        carousel.init();
        game.init();
        window.p5Instance = new p5(sketch, "canvas-container");
        document
          .getElementById("reset-view-btn")
          .addEventListener("click", () => {
            if (window.p5Instance) {
              window.p5Instance.resetView();
            }
          });
      });
    </script>
  </body>
</html>
